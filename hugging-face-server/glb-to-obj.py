"""
GLB to OBJ Converter
Converts GLB files to OBJ with materials and textures for Unity import
"""

import os
import shutil
import trimesh
import numpy as np
from PIL import Image


def convert_glb_to_obj(glb_path: str, output_dir: str = None) -> dict:
    """
    Convert a GLB file to OBJ format with materials and textures
    
    Args:
        glb_path: Path to the input GLB file
        output_dir: Output directory (defaults to same dir as GLB)
    
    Returns:
        dict with paths to generated files
    """
    if not os.path.exists(glb_path):
        raise FileNotFoundError(f"GLB file not found: {glb_path}")
    
    # Setup output directory
    base_name = os.path.splitext(os.path.basename(glb_path))[0]
    base_name = base_name.replace(" ", "_").replace("(", "").replace(")", "")
    
    if output_dir is None:
        output_dir = os.path.dirname(glb_path)
    
    asset_dir = os.path.join(output_dir, base_name)
    textures_dir = os.path.join(asset_dir, "textures")
    
    os.makedirs(asset_dir, exist_ok=True)
    os.makedirs(textures_dir, exist_ok=True)
    
    print(f"Loading GLB: {glb_path}")
    
    # Load the GLB file
    scene = trimesh.load(glb_path, force='scene')
    
    result = {
        "obj_path": None,
        "mtl_path": None,
        "textures": [],
        "asset_dir": asset_dir
    }
    
    # Export paths
    obj_path = os.path.join(asset_dir, f"{base_name}.obj")
    mtl_path = os.path.join(asset_dir, f"{base_name}.mtl")
    
    # Handle scene vs single mesh
    if isinstance(scene, trimesh.Scene):
        print(f"Scene contains {len(scene.geometry)} geometries")
        
        # Try to get combined mesh
        try:
            # Dump all meshes
            meshes = list(scene.geometry.values())
            if len(meshes) == 1:
                mesh = meshes[0]
            else:
                # Combine all meshes
                mesh = trimesh.util.concatenate(meshes)
            print(f"Combined mesh: {len(mesh.vertices)} vertices, {len(mesh.faces)} faces")
        except Exception as e:
            print(f"Could not combine meshes: {e}")
            # Export scene directly
            scene.export(obj_path)
            result["obj_path"] = obj_path
            return result
    else:
        mesh = scene
        print(f"Single mesh: {len(mesh.vertices)} vertices, {len(mesh.faces)} faces")
    
    # Extract and save textures from visual
    texture_index = 0
    material_info = {}
    
    if hasattr(mesh, 'visual'):
        visual = mesh.visual
        
        # Handle TextureVisuals
        if hasattr(visual, 'material'):
            mat = visual.material
            print(f"Material type: {type(mat).__name__}")
            
            # Extract material properties
            if hasattr(mat, 'baseColorFactor'):
                material_info['diffuse'] = mat.baseColorFactor[:3] if len(mat.baseColorFactor) >= 3 else [0.8, 0.8, 0.8]
            elif hasattr(mat, 'diffuse'):
                material_info['diffuse'] = mat.diffuse[:3] if mat.diffuse is not None else [0.8, 0.8, 0.8]
            
            # Extract textures
            texture_attrs = ['baseColorTexture', 'image', 'diffuse']
            for attr in texture_attrs:
                if hasattr(mat, attr):
                    tex = getattr(mat, attr)
                    if tex is not None and hasattr(tex, 'size'):
                        # It's an image
                        tex_filename = f"texture_{texture_index}.png"
                        tex_path = os.path.join(textures_dir, tex_filename)
                        tex.save(tex_path)
                        result["textures"].append(tex_path)
                        material_info['map_Kd'] = os.path.join("textures", tex_filename)
                        print(f"Saved texture: {tex_path}")
                        texture_index += 1
                        break
        
        # Handle ColorVisuals (vertex colors)
        if hasattr(visual, 'vertex_colors') and visual.vertex_colors is not None:
            print("Mesh has vertex colors")
            # Average color for material
            avg_color = np.mean(visual.vertex_colors[:, :3], axis=0) / 255.0
            material_info['diffuse'] = avg_color.tolist()
    
    # Write MTL file
    with open(mtl_path, 'w') as f:
        f.write(f"# Material file for {base_name}\n")
        f.write(f"# Generated by glb-to-obj.py\n\n")
        f.write(f"newmtl {base_name}_material\n")
        
        # Diffuse color
        diffuse = material_info.get('diffuse', [0.8, 0.8, 0.8])
        f.write(f"Kd {diffuse[0]:.4f} {diffuse[1]:.4f} {diffuse[2]:.4f}\n")
        
        # Ambient (slight)
        f.write(f"Ka 0.1 0.1 0.1\n")
        
        # Specular
        f.write(f"Ks 0.3 0.3 0.3\n")
        f.write(f"Ns 100.0\n")
        
        # Transparency
        f.write(f"d 1.0\n")
        
        # Texture map if exists
        if 'map_Kd' in material_info:
            f.write(f"map_Kd {material_info['map_Kd']}\n")
    
    result["mtl_path"] = mtl_path
    print(f"Saved material: {mtl_path}")
    
    # Write OBJ file
    with open(obj_path, 'w') as f:
        f.write(f"# OBJ file for {base_name}\n")
        f.write(f"# Generated by glb-to-obj.py\n")
        f.write(f"# Vertices: {len(mesh.vertices)}\n")
        f.write(f"# Faces: {len(mesh.faces)}\n\n")
        f.write(f"mtllib {base_name}.mtl\n\n")
        
        # Write vertices
        for v in mesh.vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
        
        # Write texture coordinates if available
        if hasattr(mesh.visual, 'uv') and mesh.visual.uv is not None:
            f.write("\n# Texture coordinates\n")
            for uv in mesh.visual.uv:
                f.write(f"vt {uv[0]:.6f} {uv[1]:.6f}\n")
            has_uvs = True
        else:
            has_uvs = False
        
        # Write normals if available
        if mesh.vertex_normals is not None:
            f.write("\n# Vertex normals\n")
            for n in mesh.vertex_normals:
                f.write(f"vn {n[0]:.6f} {n[1]:.6f} {n[2]:.6f}\n")
            has_normals = True
        else:
            has_normals = False
        
        # Use material
        f.write(f"\nusemtl {base_name}_material\n")
        f.write(f"s 1\n\n")
        
        # Write faces (OBJ uses 1-based indexing)
        f.write("# Faces\n")
        for face in mesh.faces:
            if has_uvs and has_normals:
                f.write(f"f {face[0]+1}/{face[0]+1}/{face[0]+1} {face[1]+1}/{face[1]+1}/{face[1]+1} {face[2]+1}/{face[2]+1}/{face[2]+1}\n")
            elif has_normals:
                f.write(f"f {face[0]+1}//{face[0]+1} {face[1]+1}//{face[1]+1} {face[2]+1}//{face[2]+1}\n")
            elif has_uvs:
                f.write(f"f {face[0]+1}/{face[0]+1} {face[1]+1}/{face[1]+1} {face[2]+1}/{face[2]+1}\n")
            else:
                f.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")
    
    result["obj_path"] = obj_path
    print(f"Saved OBJ: {obj_path}")
    
    # Print summary
    print(f"\n{'='*50}")
    print(f"Conversion complete!")
    print(f"{'='*50}")
    print(f"Output directory: {asset_dir}")
    print(f"  - OBJ: {os.path.basename(obj_path)}")
    print(f"  - MTL: {os.path.basename(mtl_path)}")
    if result["textures"]:
        print(f"  - Textures: {len(result['textures'])} files")
        for tex in result["textures"]:
            print(f"      {os.path.basename(tex)}")
    
    return result


def batch_convert(input_dir: str, output_dir: str = None) -> list:
    """Convert all GLB files in a directory"""
    results = []
    
    for filename in os.listdir(input_dir):
        if filename.lower().endswith('.glb'):
            glb_path = os.path.join(input_dir, filename)
            try:
                result = convert_glb_to_obj(glb_path, output_dir)
                results.append(result)
            except Exception as e:
                print(f"Error converting {filename}: {e}")
    
    return results


if __name__ == "__main__":
    import sys
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # Check command line args or use default
    if len(sys.argv) > 1:
        glb_path = sys.argv[1]
    else:
        # Default: look for the textured_mesh file
        glb_path = os.path.join(script_dir, "textured_mesh (1).glb")
    
    output_dir = os.path.join(script_dir, "output")
    
    if not os.path.exists(glb_path):
        print(f"GLB file not found: {glb_path}")
        print("\nUsage: python glb-to-obj.py <path_to_glb>")
        print("       python glb-to-obj.py  (uses default textured_mesh (1).glb)")
        sys.exit(1)
    
    try:
        result = convert_glb_to_obj(glb_path, output_dir)
        print(f"\n✅ Unity-ready assets saved to: {result['asset_dir']}")
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

